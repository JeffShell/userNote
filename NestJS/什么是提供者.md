# 什么是提供者

提供者（Provider）, 是Nest的一个基本概念,主要思想是可以被作为依赖注入, 意味着可以在对象之间创建各种关系。

## 语法

定义一个service文件
```TypeScript
const posts = [
    {title: '第一篇文章', body: '第一篇的内容'}
    //.....
].map((v, id) => ({...v, id}))

@Injectable()
export class UserService {
    async findAll(){
        return posts;
    }
    async create(data){
        const newPost = [
            //创建一些新的数据
        ]
        return newPost;
    }
}

```

在一个module文件夹下,声明一个 module,
```TypeScript
// module/user.module.ts
import { UserController } from "./user.controllers.ts"
import { UserService } from "./user.service.ts"
@Module({
    controllers: [UserController],  //引用控制器
    providers: [UserService] //引用提供者
})
```

`user.service.ts` 可以被使用了
```TypeScript
// module/user.controllers.ts
import { UserService } from "./user.service"

@Controller('user')
export cless UserController {
    //使用service
    constructor(private readonly userService: UserService){}
    //以下代码就引用了该提供者的功能

    @Post()
    create(@Body() value){
        return this.userService.create(value)
    }
    @Get()
    findAll(){
        return this.userService.findAll()
    }
}
```



## 第二种定义 service

以上在 `user.module.ts` 文件里， `@Module` 修饰符的`providers` 选项，这样的引用 提供者的用法，称为**标准提供者（Standard providers）**

而下面的写法，则是自定义写法 ，又叫 **自定义提供者** ，这样的写法分了几种： 
+ `useValue`：值自定义
+ `useClass`：类自定义
+ `useFactory`：工厂自定义
+ `useExisting`：别名自定义


### 类自定义

```TypeScript
// module/user.module.ts
import { UserController } from "./user.controllers.ts"
import { UserService } from "./user.service.ts"
@Module({
    controllers: [UserController],  //引用控制器
    providers: [{
        provide: 'xiaomin', //名称为自定义，想叫什么就叫什么
        userClass: UserService
    }] //引用提供者
})
```

需要注意的是，使用了自定义写法，在注入的使用不能像上面那样使用，而是在参数的前面多加一个装饰器 `@inject` ，如下写法：

```TypeScript
// module/user.controllers.ts
import { UserService } from "./user.service"

@Controller('user')
export cless UserController {
    //使用service
    constructor(@inject('xiaomin') private readonly userService: UserService){}
    //....
}
```

### 值自定义

除了名称可自定义外，注入值还可以自定义, 如果注入的是值，那么就需要用`userValue`，如下

```TypeScript

// module/user.module.ts
import { UserController } from "./user.controllers.ts"
@Module({
    controllers: [UserController],  //引用控制器
    providers: [{
        provide: 'userArr', 
        userValue: ['小明', '小红', '小亮']
    }]
```
注入如下：
```TypeScript
// module/user.controllers.ts

@Controller('user')
export cless UserController {
    //使用service
    constructor(@inject('userArr') private readonly userList: string[]){}
    @Get()
    findAll(){
        return this.userList
    }
    //....
}
```

### 工厂自定义

此写法允许动态的创建提供者， 实际的提供者是由工厂函数返回的值为提供者。

如果 service 文件之间有相互的依赖或者有逻辑上的联系，可以使用`userFactory`

```TypeScript
import { UserService } from './user.service';
import { UserService2 } from './user.service2';
import { UserService3 } from './user.service3';

@Module({
    controllers: [UserController],
    providers: [
        UserService,
    {
        provide: 'userArr', 
        userClass: ['小明', '小红', '小亮']
    }, {
        provide: 'test',
        inject: [UserService2], //如果希望 useFactory 接受一个参数，使用inject选项注入该参数，然后在useFactory 使用该参数，反之不接受参数就不用写inject选项
        useFactory(UserService2) {
            return new UserService3(userService2)
        }
    },{
        provide: 'test2',
        useFactory() {
            return new UserService3()
        }
    }]
})
export class UserModule{}
```

## 异步操作

在service是支持异步操作的，写法如下: 
```TypeScript

@Module({
    controllers: [UserController],
    providers: [ {
        provide: 'sync',
        async useFactory() {
            return await new Promise(resolve => {
                setTimeout(() => {
                    resolve('sync')
                }, 3000)
            })
        }
    }]
})
export class UserModule{}
``` 

## 导出提供者

如果其他的模块想使用本模块的提供者，可以这样写：
```ts
//xxx.service.ts
const connectionFactory = {
    provide: 'CONNECTION',
    useFactory: () => {
        return //....
    }
}

//xxx.module.ts
@Module({
    providers: [connectionFactory],
    exports: ['CONNECTION'] // or  exports: [connectionFactory]
})
export class AppModule {}
```